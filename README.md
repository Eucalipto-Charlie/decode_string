# 字符串解码算法（Rust 实现）

## 项目简介：  
实现一个算法，解码形如 `k[encoded_string]` 的字符串表达式。

例如：  
- 输入：`3[a]2[bc]` → 输出：`aaabcbc`  
- 输入：`3[a2[c]]` → 输出：`accaccacc`  
- 输入：`2[abc]3[cd]ef` → 输出：`abcabccdcdcdef`

---

## 问题描述
给定一个经过编码的字符串 `s`，请实现一个算法来解码它。  
编码规则如下：
- `k[encoded_string]` 表示括号内的字符串重复 `k` 次；
- `k` 为一个正整数；
- 输入字符串总是有效的；
- 所有括号均成对匹配；
- 数字只用于重复次数，不会出现在原始字符串中。

**输出**：去除括号与数字后的完整解码字符串。

---

## 解题思路

该问题可以用 **栈（Stack）结构** 解决。

### 核心思想
- 当遇到 数字 时，说明后面会有对应的重复段，临时存入 `num_stack`；
- 当遇到 左括号 `[` 时，说明开始进入一个新的嵌套段：
  - 把当前构造好的字符串压入 `str_stack`；
  - 重置当前字符串；
- 当遇到 右括号 `]` 时，说明一个嵌套段结束：
  - 从 `num_stack` 取出重复次数；
  - 从 `str_stack` 取出之前的字符串；
  - 将当前段重复拼接后附加回去；
- 其余普通字符，直接加入当前字符串。

### 示例：`2[ab]z2[cd]y3[e2[fg]h]`
运行过程如下：
| 步骤 | 当前字符 | 操作说明 | 当前结果 |
|------|----------|----------|-----------|
|   1  |   `2`    | 读到数字 `2` | num = 2 |
|   2  |   `[`    | 压栈 num=2，保存当前串="" | str_stack=[""], num_stack=[2] |
|   3  |   `a`    | 加入当前串 | curr="a" |
|   4  |   `b`    | 加入当前串 | curr="ab" |
|   5  |   `]`    | 出栈并重复 | curr="ab"×2 → "abab" |
|   6  |   `z`    | 普通字符   | curr="ababz" |
|   7  |   `2`    | 新一轮数字 | num=2 |
|   8  |   `[`    | 压栈       | str_stack=["ababz"], num_stack=[2] |
|   9  |   `c`    | 加入当前串 | curr="c" |
|  10  |   `d`    | 加入当前串 | curr="cd" |
|  11  |   `]`    | 出栈重复并拼接 | curr="ababz" + "cdcd" → "ababzcdcd" |
|  12  |   `y`    | 普通字符   | curr="ababzcdcdy" |
|  13  |   `3`    | 数字       | num=3 |
|  14  |   `[`    | 压栈       | str_stack=["ababzcdcdy"], num_stack=[3] |
|  15  |   `e`    | 加入当前串 | curr="e" |
|  16  |   `2`    | 数字       | num=2 |
|  17  |   `[`    | 压栈       | str_stack=["ababzcdcdy","e"], num_stack=[3,2] |
|  18  |   `f`    | 加入       | curr="f" |
|  19  |   `g`    | 加入       | curr="fg" |
|  20  |   `]`    | 出栈重复   | curr="e" + "fgfg" = "efgfg" |
|  21  |   `h`    | 加入       | curr="efgfgh" |
|  22  |   `]`    | 出栈重复   | curr="ababzcdcdy" + ("efgfgh"×3) |
| 最终输出 | `"ababzcdcdyefgfghefgfghefgfgh"` |
